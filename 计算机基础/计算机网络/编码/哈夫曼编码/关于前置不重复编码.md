# 前置不重复编码

每次的路径是二叉树的向下查找，下一步如果不在子节点中，直接取当前节点为码位。

思考：我们如何构造这颗二叉树呢？

条件：

1. 直观的体现
G
假如一串编码：267878268766

我们需要一种方式，在不定长编码的情况下，识别对应到的解码

比如：   
如果 2 找到了对应的解码值，直接返回解码值，如果没有，继续识别 26
如果 26 找到了对应的解码值，直接返回解码值，否则，继续识别 267
以此类推...
（如果遇到有就返回，没有继续往下走）

我们一步步来设计：  
如果 2 对应有值为 a，那么所有的 2 都会返回 a
那么就不存在 2 + n 的组合

如果 6 对应有值为 b，那么所有的 6 都会返回 b
那么就不存在 6 + n 的组合

依次：
7 -> c
8 -> d

上边的编码为： abcdcdabdcbb  

那么什么情况下出现不够用呢？ 
13142678907456433499
1 -> a
2 -> b
3 -> c
4 -> d
5 -> e
6 -> f
7 -> g
9 -> h
0 -> i

注意，这里不能有 10，10 会对应 a i

如果我们想编码 i 后面的字母，一定不能是 0 ~ 9开头


假如 1 能拿到对应的编码，就直接拿k


2. 思考2，走到叶子节点
   1        0
 1   0    1   0
1 0 1 0  1 0 1 0

3. 查阅后思考 3

0
10
110
111

... 没路了

**补码**才有路，被定长编码迷惑了
0
10
110
1110

加一位，永远不封路就行了


题目：
给定字符集和频率如下：
字符	频率
A	5
B	9
C	12
D	13
E	16
F	45

0
10
110
1110
11110
111110

F -> 0
E -> 10 
D -> 110
C -> 1110
B -> 11110
A -> 111110

F -> 0
E -> 101
D -> 100
C -> 111
B -> 1101
A -> 1100
这里还有个问题，好像二进制多长，就是几个码位呀
