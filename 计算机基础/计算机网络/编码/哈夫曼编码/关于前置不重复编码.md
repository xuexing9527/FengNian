# 前置不重复编码

每次的路径是二叉树的向下查找，下一步如果不在子节点中，直接取当前节点为码位。

思考：我们如何构造这颗二叉树呢？

条件：

1. 直观的体现

假如一串编码：267878268766

我们需要一种方式，在不定长编码的情况下，识别对应到的解码

比如：   
如果 2 找到了对应的解码值，直接返回解码值，如果没有，继续识别 26
如果 26 找到了对应的解码值，直接返回解码值，否则，继续识别 267
以此类推...
（如果遇到有就返回，没有继续往下走）

我们一步步来设计：  
如果 2 对应有值为 a，那么所有的 2 都会返回 a
那么就不存在 2 + n 的组合

如果 6 对应有值为 b，那么所有的 6 都会返回 b
那么就不存在 6 + n 的组合

依次：
7 -> c
8 -> d

上边的编码为： abcdcdabdcbb  

那么什么情况下出现不够用呢？ 
13142678907456433499
1 -> a
2 -> b
3 -> c
4 -> d
5 -> e
6 -> f
7 -> g
9 -> h
0 -> i

注意，这里不能有 10，10 会对应 a i

如果我们想编码 i 后面的字母，一定不能是 0 ~ 9开头


假如 1 能拿到对应的编码，就直接拿k
