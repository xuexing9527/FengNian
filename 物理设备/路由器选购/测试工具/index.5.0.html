<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>è·¯ç”±å™¨è‡ªé€‚åº”å‹åŠ›æµ‹è¯• Demo</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; background: #f4f4f4; }
    h1 { color: #333; }
    input, button { padding: 6px; margin: 5px 0; }
    button { cursor: pointer; border-radius: 6px; border: none; background: #007bff; color: white; }
    button:hover { background: #0056b3; }
    #results { margin-top: 20px; padding: 15px; background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    canvas { background: #fff; border: 1px solid #ccc; margin-top: 10px; border-radius: 6px; }
    #countdown { font-weight: bold; color: #d9534f; }
  </style>
</head>
<body>
  <h1>è·¯ç”±å™¨è‡ªé€‚åº”å‹åŠ›æµ‹è¯• Demo</h1>
  <p>è®¾ç½®å¹¶å‘è¯·æ±‚æ•°å’Œæµ‹è¯•æ—¶é•¿ï¼Œç‚¹å‡»å¼€å§‹æµ‹è¯•ã€‚</p>
  <label>å¹¶å‘è¯·æ±‚æ•°: <input type="number" id="concurrent" value="5" min="1" max="50"></label><br>
  <label>æµ‹è¯•æ—¶é•¿(ç§’): <input type="number" id="duration" value="300" min="10" max="600"></label><br>
  <button id="startTest">å¼€å§‹å‹åŠ›æµ‹è¯•</button>

  <div id="countdown"></div>
  <div id="results"></div>

  <canvas id="latencyChart" width="600" height="200"></canvas>
  <canvas id="speedChart" width="600" height="200"></canvas>
  <canvas id="stabilityChart" width="600" height="200"></canvas>

  <script>
    const resultsDiv = document.getElementById('results');
    const countdownDiv = document.getElementById('countdown');
    const latencyCanvas = document.getElementById('latencyChart').getContext('2d');
    const speedCanvas = document.getElementById('speedChart').getContext('2d');
    const stabilityCanvas = document.getElementById('stabilityChart').getContext('2d');

    async function singleRequest(url="https://speed.cloudflare.com/__down?bytes=1000000") {
      const start = performance.now();
      try {
        const response = await fetch(url + "?cachebuster=" + Math.random(), {cache:"no-store"});
        const blob = await response.blob();
        const end = performance.now();
        const duration = end - start;
        const speedMbps = (blob.size * 8 / duration * 1000 / (1024*1024)).toFixed(2); // Mbps
        return {latency: parseFloat(duration.toFixed(2)), speed: parseFloat(speedMbps), success: true};
      } catch {
        return {latency: null, speed: 0, success: false};
      }
    }

    function drawChart(ctx, data, label) {
      ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
      ctx.beginPath();
      ctx.moveTo(0, ctx.canvas.height - (data[0]||0));
      for(let i=1;i<data.length;i++){
        ctx.lineTo(i*(ctx.canvas.width/data.length), ctx.canvas.height - (data[i]||0));
      }
      ctx.strokeStyle = "#007bff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle="#333";
      ctx.fillText(label, 10, 10);
    }

    function stabilityGrade(score) {
      if(score>=90) return "ä¼˜ç§€ âœ…";
      if(score>=70) return "è‰¯å¥½ ğŸ‘";
      if(score>=50) return "ä¸€èˆ¬ ğŸ˜";
      return "è¾ƒå·® âŒ";
    }

    document.getElementById('startTest').addEventListener('click', async () => {
      const concurrent = parseInt(document.getElementById('concurrent').value) || 5;
      const duration = parseInt(document.getElementById('duration').value) || 300;
      resultsDiv.innerHTML = "<p class='metric'>æµ‹è¯•ä¸­ï¼Œè¯·è€å¿ƒç­‰å¾…...</p>";

      const latencyData=[], speedData=[], stabilityData=[];
      let totalRequests=0, failedRequests=0;

      for(let sec=duration; sec>0; sec--){
        countdownDiv.textContent = `å€’è®¡æ—¶ï¼š${sec} ç§’`;

        const promises = [];
        for(let i=0;i<concurrent;i++){
          promises.push(singleRequest());
        }
        const results = await Promise.all(promises);

        let sumLatency=0, sumSpeed=0, successCount=0;
        results.forEach(r=>{
          totalRequests++;
          if(r.success){
            successCount++;
            sumLatency += r.latency;
            sumSpeed += r.speed;
          } else failedRequests++;
        });

        const avgLatency = successCount>0 ? sumLatency/successCount : 0;
        const avgSpeed = successCount>0 ? sumSpeed/successCount : 0;
        const stabilityScore = Math.max(0, 100 - failedRequests/totalRequests*100);

        latencyData.push(avgLatency*0.5); // ç¼©æ”¾æ˜¾ç¤º
        speedData.push(avgSpeed*2);       // ç¼©æ”¾æ˜¾ç¤º
        stabilityData.push(stabilityScore);

        // å®æ—¶ç»˜åˆ¶æ›²çº¿
        drawChart(latencyCanvas, latencyData, "å»¶è¿Ÿ(ms,ç¼©æ”¾)");
        drawChart(speedCanvas, speedData, "ä¸‹è½½é€Ÿåº¦(Mbps,ç¼©æ”¾)");
        drawChart(stabilityCanvas, stabilityData, "ç¨³å®šæ€§è¯„åˆ†");
      }

      // æœ€ç»ˆç»“æœ
      const finalScore = Math.max(0, 100 - failedRequests/totalRequests*100);
      resultsDiv.innerHTML = `
        <div class="metric"><b>æ€»è¯·æ±‚ï¼š</b>${totalRequests}</div>
        <div class="metric"><b>å¤±è´¥è¯·æ±‚ï¼š</b>${failedRequests}</div>
        <div class="metric"><b>æœ€ç»ˆç¨³å®šæ€§è¯„åˆ†ï¼š</b>${finalScore.toFixed(0)} / 100</div>
        <div class="metric"><b>å‹åŠ›åˆ†çº§ï¼š</b>${stabilityGrade(finalScore)}</div>
        <p>æ›²çº¿å›¾å®æ—¶æ˜¾ç¤ºå»¶è¿Ÿã€é€Ÿåº¦å’Œç¨³å®šæ€§å˜åŒ–ï¼Œè¶Šå¹³æ»‘è¶Šç¨³å®šã€‚</p>
      `;
      countdownDiv.textContent = "æµ‹è¯•å®Œæˆ âœ…";
    });
  </script>
</body>
</html>
