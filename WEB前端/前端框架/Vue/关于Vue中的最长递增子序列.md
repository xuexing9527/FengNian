# 最长递增自序列的应用场景
## 优化 DOM diff 算法
列表的优化，举例：
````html
<!-- 列表1 -->
<ul>
    <li>A</li> <li>B</li> <li>C</li> <li>D</li> <li>E</li>
</ul>
<!-- 到 =>  -->
<!-- 列表2 -->
<ul>
    <li>A</li> <li>D</li> <li>B</li> <li>F</li> <li>C</li>
</ul>
````
代码中从列表 1 到列表 2：
我们列表 1 的 DOM 顺序为 A, B, C, D, E，编号对应数组为：`[0, 1, 2, 3, 4]`  
到  
列表 2 的 DOM 顺序为 A, D, B, F，C 编号对应数组为：`[0, 3, 1, 'F 被新增', 2, 'E 被删除']`，我们不看新增和删除得到数组：`[0, 3, 1, 2]`  

这里的优化在于 **（敲黑板）**：数组 `[0, 1, 2, 3, 4]` => `[0, 3, 1, 2]`，最长递增子序列为：`[0, 1, 2]`，  

此时 Vue 会选择 0，1，2 位置的 DOM 不做移动，移动其它非递增位置的元素，比如移动 3 位置的 DOM 元素。并不是重排一次 DOM 顺序，这样可以**尽可能减少 DOM 的移动次数，减少浏览器回流或重绘的次数**，进而提高性能。

【思考：这里是不是有问题？都放到 fragment 排序完成，一次行挂载也 OK。至于少移动次数，应该建立在每次都移动并更新 DOM，这样的效率一定是低的。推测：如果通过只挂载一次，重排一次 DOM 顺序，并不复杂。这里要深入考虑 Vue 是如何批量操作 DOM 的？fragment 是否可以替代最长递增子序列的优化。（提问时间：2024.10.19）】