<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<title>实时逐字识别 — 可自定义分隔符 & 时间日志</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans CJK SC", "PingFang SC", "Microsoft YaHei", Arial; padding: 18px; }
  .controls { margin-bottom: 10px; }
  button { padding: 8px 12px; margin-right: 8px; }
  label { margin-right: 6px; }
  input[type="number"], input[type="text"] { padding: 6px; width: 100px; margin-right: 8px; }
  textarea { width: 100%; box-sizing: border-box; font-size: 16px; line-height: 1.6; margin-top: 8px; }
  #finalArea { height: 180px; white-space: pre-wrap; }
  #draftArea { height: 110px; color: #444; }
  #log { height: 200px; overflow: auto; background: #111; color: #0f0; padding: 8px; font-family: monospace; margin-top: 10px; }
  .small { font-size: 13px; color: #666; margin-left: 6px; }
</style>
</head>
<body>
  <h2>实时逐字识别 — 分隔符 & 时间日志</h2>

  <div class="controls">
    <button id="startBtn">开始</button>
    <button id="stopBtn">停止</button>
    <button id="copyBtn">复制正式区</button>
    <span class="small">（建议用 Chrome/Edge）</span>
  </div>

  <div class="controls">
    <label for="spacer">每字分隔符：</label>
    <input id="spacer" type="text" value=" " title="在每个字之间插入的字符串，支持多个字符">
    <label for="pauseInterval">停顿阈值（秒）：</label>
    <input id="pauseInterval" type="number" min="0.05" step="0.05" value="0.2">
    <span class="small">当识别事件间隔 ≥ 阈值，会先额外插入一次分隔符</span>
  </div>

  <h3>正式区（逐字输出 + 自定义分隔）</h3>
  <textarea id="finalArea" readonly placeholder="正式输出：逐字分隔（在 textarea 中空格会被保留）"></textarea>

  <h3>草稿区（原始实时识别，用于观察 interim）</h3>
  <textarea id="draftArea" readonly placeholder="实时识别（interim）会显示在这里"></textarea>

  <h3>时间日志（每次新增记录）：</h3>
  <div id="log" aria-live="polite"></div>

<script>
(function(){
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert('浏览器不支持 SpeechRecognition，请用 Chrome/Edge（桌面）测试。');
    // still render controls but disable
  }

  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const copyBtn = document.getElementById('copyBtn');
  const spacerInput = document.getElementById('spacer');
  const pauseIntervalInput = document.getElementById('pauseInterval');

  const finalArea = document.getElementById('finalArea');
  const draftArea = document.getElementById('draftArea');
  const logEl = document.getElementById('log');

  let recognition = null;
  let isRunning = false;

  let lastFull = "";      // 上次识别的完整字符串（去空白）
  let finalText = "";     // 正式区文本（带分隔）
  let lastEventTs = Date.now();  // 上次识别事件时间戳 ms

  function appendLogEntry(obj) {
    // obj: { eventInterval, delta, assignedPerChar, time }
    const t = new Date(obj.time);
    const timeStr = t.toLocaleTimeString() + '.' + String(t.getMilliseconds()).padStart(3,'0');
    // Build human readable lines
    let lines = [];
    lines.push(`${timeStr}  eventInterval=${obj.eventInterval} ms  chars=${obj.delta.length}`);
    // show each char with assigned ms
    const chars = obj.delta.split('');
    const per = obj.assignedPerChar;
    const charParts = chars.map((ch, idx) => {
      // escape newlines or invisible
      const display = ch === '\n' ? '\\n' : (ch === ' ' ? '·' : ch);
      return `${display}[${Math.round(per)}ms]`;
    });
    lines.push('  ' + charParts.join(' '));
    // Print to log
    logEl.textContent = lines.join('\n') + '\n' + logEl.textContent;
  }

  function initRecognition() {
    recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = 'zh-CN';
    recognition.maxAlternatives = 1;

    recognition.onresult = (ev) => {
      // combine all results (ordered)
      let combined = "";
      for (let i = 0; i < ev.results.length; i++) {
        combined += ev.results[i][0].transcript;
      }

      // show draft as-is (may contain spaces)
      draftArea.value = combined;

      // normalize: remove whitespace so we treat characters
      const full = combined.replace(/\s+/g, '');

      // compute delta
      let delta = "";
      if (full.length > lastFull.length) {
        delta = full.slice(lastFull.length);
      }

      if (delta) {
        const now = Date.now();
        const eventInterval = now - lastEventTs; // ms between recognition events (we'll show this)
        const gapSec = parseFloat(pauseIntervalInput.value) || 0.2;
        const gapMs = gapSec * 1000;

        // If time since last event >= threshold, insert one spacer before adding new chars
        if (eventInterval >= gapMs) {
          finalText += spacerInput.value;
        }

        // per-char separator string:
        const sep = spacerInput.value;

        // Append delta: each char separated by sep
        // e.g. delta="去跑" sep=" " => append "去 跑"
        const spaced = delta.split('').join(sep);
        finalText += spaced;
        finalArea.value = finalText;

        // For logging: we can't know per-char actual speaking times; show eventInterval and assigned per-char ms
        const assignedPerChar = eventInterval / Math.max(1, delta.length);

        appendLogEntry({
          eventInterval,
          delta,
          assignedPerChar,
          time: now
        });

        lastEventTs = now;
      }

      lastFull = full;
    };

    recognition.onerror = (e) => {
      console.warn('SpeechRecognition error', e);
    };

    recognition.onend = () => {
      isRunning = false;
      startBtn.disabled = false;
    };
  }

  startBtn.addEventListener('click', () => {
    if (!SpeechRecognition) return;
    if (isRunning) return;
    initRecognition();
    try {
      recognition.start();
      isRunning = true;
      startBtn.disabled = true;
      // reset state
      lastFull = "";
      finalText = "";
      finalArea.value = "";
      draftArea.value = "";
      logEl.textContent = '';
      lastEventTs = Date.now();
    } catch (err) {
      console.error('start error', err);
    }
  });

  stopBtn.addEventListener('click', () => {
    if (!isRunning || !recognition) return;
    try {
      recognition.stop();
    } catch (_) {}
    isRunning = false;
    startBtn.disabled = false;
  });

  copyBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(finalText);
      alert('已复制正式区文本');
    } catch (err) {
      alert('复制失败（请检查浏览器权限）');
    }
  });

})();
</script>
</body>
</html>
