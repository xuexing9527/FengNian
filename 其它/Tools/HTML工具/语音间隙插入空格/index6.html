<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<title>逐字识别 — 多重分隔插入（修正版）</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans CJK SC", "PingFang SC", "Microsoft YaHei", Arial; padding: 18px; }
  .controls { margin-bottom: 10px; }
  button { padding: 8px 12px; margin-right: 8px; }
  label { margin-right: 6px; }
  input[type="number"], input[type="text"] { padding: 6px; width: 110px; margin-right: 8px; }
  textarea { width: 100%; box-sizing: border-box; font-size: 16px; line-height: 1.6; margin-top: 8px; }
  #finalArea { height: 180px; white-space: pre-wrap; }
  #draftArea { height: 110px; color: #444; }
  #log { height: 220px; overflow: auto; background: #0b0b0b; color: #cfe; padding: 8px; font-family: monospace; margin-top: 10px; }
  .small { font-size: 13px; color: #666; margin-left: 6px; }
</style>
</head>
<body>
  <h2>逐字识别 — 多重分隔插入（修正版）</h2>

  <div class="controls">
    <button id="startBtn">开始</button>
    <button id="stopBtn">停止</button>
    <button id="copyBtn">复制正式区</button>
    <span class="small">（Chrome / Edge 桌面上测试最佳）</span>
  </div>

  <div class="controls">
    <label for="spacer">每字分隔符：</label>
    <input id="spacer" type="text" value=" " title="在每个字之间插入的字符串，支持多个字符">
    <label for="pauseInterval">停顿阈值（秒）：</label>
    <input id="pauseInterval" type="number" min="0.01" step="0.01" value="0.2">
    <label for="maxCount">单次最大插入次数：</label>
    <input id="maxCount" type="number" min="1" step="1" value="200" style="width:80px;">
  </div>

  <h3>正式区（逐字输出 + 可重复插入分隔）</h3>
  <textarea id="finalArea" readonly placeholder="正式输出：逐字分隔（textarea 中空格会被保留）"></textarea>

  <h3>草稿区（原始实时识别）</h3>
  <textarea id="draftArea" readonly placeholder="实时识别（interim）会显示在这里"></textarea>

  <h3>时间日志（每次新增记录，最新在上）</h3>
  <div id="log" aria-live="polite"></div>

<script>
(function(){
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert('浏览器不支持 SpeechRecognition，请用 Chrome/Edge（桌面）测试。');
  }

  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const copyBtn = document.getElementById('copyBtn');
  const spacerInput = document.getElementById('spacer');
  const pauseIntervalInput = document.getElementById('pauseInterval');
  const maxCountInput = document.getElementById('maxCount');

  const finalArea = document.getElementById('finalArea');
  const draftArea = document.getElementById('draftArea');
  const logEl = document.getElementById('log');

  let recognition = null;
  let isRunning = false;

  let lastFull = "";      // 上次识别的完整字符串（去空白）
  let finalText = "";     // 正式区文本（带分隔）
  let lastEventTs = Date.now();  // 上次识别事件时间戳 ms

  function appendLogEntry(obj) {
    const t = new Date(obj.time);
    const timeStr = t.toLocaleTimeString() + '.' + String(t.getMilliseconds()).padStart(3,'0');
    const lines = [];
    lines.push(`${timeStr}  eventInterval=${obj.eventInterval} ms  insertedCount=${obj.insertedCount}  chars=${obj.delta.length}`);
    const chars = obj.delta.split('');
    const per = obj.assignedPerChar;
    const charParts = chars.map(ch => {
      const display = ch === '\n' ? '\\n' : (ch === ' ' ? '·' : ch);
      return `${display}[${Math.round(per)}ms]`;
    });
    lines.push('  ' + charParts.join(' '));
    logEl.textContent = lines.join('\n') + '\n' + logEl.textContent;
  }

  function initRecognition() {
    recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = 'zh-CN';
    recognition.maxAlternatives = 1;

    recognition.onresult = (ev) => {
      // combine transcripts
      let combined = "";
      for (let i = 0; i < ev.results.length; i++) {
        combined += ev.results[i][0].transcript;
      }

      draftArea.value = combined;
      const full = combined.replace(/\s+/g, '');

      let delta = "";
      if (full.length > lastFull.length) {
        delta = full.slice(lastFull.length);
      }

      if (delta) {
        const now = Date.now();
        const eventInterval = now - lastEventTs;
        const gapSec = parseFloat(pauseIntervalInput.value) || 0.2;
        const gapMs = Math.max(1, gapSec * 1000);
        const maxCount = Math.max(1, parseInt(maxCountInput.value, 10) || 200);

        // how many spacer insertions to perform (proportional to silence)
        let count = Math.floor(eventInterval / gapMs);
        if (count < 1) count = 1; // at least 1 if delta present (to keep some separation if desired)
        if (count > maxCount) count = maxCount;

        // If you want behavior: only insert when eventInterval >= gapMs, comment previous 'count' logic and use:
        // count = Math.floor(eventInterval / gapMs);
        // but here we keep at least 1 insertion when delta exists (so small gaps still separate)
        // If you prefer only insert when eventInterval >= gapMs, change above.

        // insert count copies of spacer BEFORE appending new chars
        const spacer = spacerInput.value || ' ';
        finalText += spacer.repeat(count);

        // append the new chars with per-char separator
        const perCharSep = spacer; // between characters
        finalText += delta.split('').join(perCharSep);

        finalArea.value = finalText;

        // logging: assigned per-char ms (eventInterval distributed)
        const assignedPerChar = eventInterval / Math.max(1, delta.length);

        appendLogEntry({
          eventInterval,
          delta,
          assignedPerChar,
          insertedCount: count,
          time: now
        });

        lastEventTs = now;
      }

      lastFull = full;
    };

    recognition.onerror = (e) => {
      console.warn('SpeechRecognition error', e);
    };

    recognition.onend = () => {
      isRunning = false;
      startBtn.disabled = false;
    };
  }

  startBtn.addEventListener('click', () => {
    if (!SpeechRecognition) return;
    if (isRunning) return;
    initRecognition();
    try {
      recognition.start();
      isRunning = true;
      startBtn.disabled = true;
      lastFull = "";
      finalText = "";
      finalArea.value = "";
      draftArea.value = "";
      logEl.textContent = '';
      lastEventTs = Date.now();
    } catch (err) {
      console.error('start error', err);
    }
  });

  stopBtn.addEventListener('click', () => {
    if (!isRunning || !recognition) return;
    try { recognition.stop(); } catch (_) {}
    isRunning = false;
    startBtn.disabled = false;
  });

  copyBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(finalText);
      alert('已复制正式区文本');
    } catch (err) {
      alert('复制失败（请检查浏览器权限）');
    }
  });

})();
</script>
</body>
</html>
