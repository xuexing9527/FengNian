<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>è·¯ç”±å™¨å‹åŠ›æµ‹è¯• Demo</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; background: #f4f4f4; }
    h1 { color: #333; }
    button { padding: 10px 20px; margin: 10px 0; cursor: pointer; border-radius: 6px; border: none; background: #007bff; color: white; }
    button:hover { background: #0056b3; }
    #results { margin-top: 20px; padding: 15px; background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .metric { margin: 8px 0; }
    canvas { background: #fff; border: 1px solid #ccc; margin-top: 10px; border-radius: 6px; }
    #countdown { font-weight: bold; color: #d9534f; }
  </style>
</head>
<body>
  <h1>è·¯ç”±å™¨å‹åŠ›æµ‹è¯• Demo</h1>
  <p>æœ¬æµ‹è¯•ä¼šè¿ç»­ 60 ç§’ï¼Œå‘å¹¶å‘è¯·æ±‚ï¼Œæ£€æµ‹å»¶è¿Ÿã€ä¸¢åŒ…å’Œä¸‹è½½é€Ÿåº¦è¡¨ç°ã€‚</p>
  <button id="startTest">å¼€å§‹å‹åŠ›æµ‹è¯•</button>
  <div id="countdown"></div>
  <div id="results"></div>

  <canvas id="latencyChart" width="600" height="200"></canvas>
  <canvas id="speedChart" width="600" height="200"></canvas>

  <script>
    const resultsDiv = document.getElementById('results');
    const countdownDiv = document.getElementById('countdown');
    const latencyCanvas = document.getElementById('latencyChart').getContext('2d');
    const speedCanvas = document.getElementById('speedChart').getContext('2d');

    async function singleRequest(url="https://speed.cloudflare.com/__down?bytes=1000000") {
      const start = performance.now();
      try {
        const response = await fetch(url + "?cachebuster=" + Math.random(), {cache:"no-store"});
        const blob = await response.blob();
        const end = performance.now();
        const duration = end - start;
        const speedMbps = (blob.size * 8 / duration * 1000 / (1024*1024)).toFixed(2); // Mbps
        return {latency: duration.toFixed(2), speed: parseFloat(speedMbps), success: true};
      } catch (err) {
        return {latency: null, speed: 0, success: false};
      }
    }

    function drawChart(canvas, data, label) {
      const ctx = canvas;
      ctx.clearRect(0,0,canvas.canvas.width, canvas.canvas.height);
      ctx.beginPath();
      ctx.moveTo(0, canvas.canvas.height - data[0]);
      for(let i=1;i<data.length;i++){
        ctx.lineTo(i*(canvas.canvas.width/data.length), canvas.canvas.height - data[i]);
      }
      ctx.strokeStyle = "#007bff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle="#333";
      ctx.fillText(label, 10, 10);
    }

    function stabilityGrade(score) {
      if(score>=90) return "ä¼˜ç§€ âœ…";
      if(score>=70) return "è‰¯å¥½ ğŸ‘";
      if(score>=50) return "ä¸€èˆ¬ ğŸ˜";
      return "è¾ƒå·® âŒ";
    }

    document.getElementById('startTest').addEventListener('click', async () => {
      resultsDiv.innerHTML = "<p class='metric'>æµ‹è¯•ä¸­ï¼Œè¯·è€å¿ƒç­‰å¾… 60 ç§’...</p>";
      countdownDiv.textContent = "å€’è®¡æ—¶ï¼š60 ç§’";

      const latencyData = [];
      const speedData = [];
      let totalRequests = 0;
      let failedRequests = 0;
      const duration = 60; // ç§’
      const concurrent = 5; // å¹¶å‘æ•°

      for (let sec=duration; sec>0; sec--) {
        countdownDiv.textContent = "å€’è®¡æ—¶ï¼š" + sec + " ç§’";

        const promises = [];
        for(let i=0;i<concurrent;i++){
          promises.push(singleRequest());
        }
        const results = await Promise.all(promises);
        let sumLatency=0, sumSpeed=0, successCount=0;
        results.forEach(r=>{
          totalRequests++;
          if(r.success){
            successCount++;
            sumLatency += parseFloat(r.latency);
            sumSpeed += r.speed;
          } else {
            failedRequests++;
          }
        });
        const avgLatency = successCount>0 ? (sumLatency/successCount).toFixed(2) : null;
        const avgSpeed = successCount>0 ? (sumSpeed/successCount).toFixed(2) : 0;
        latencyData.push(avgLatency? avgLatency*0.5 : 0); // ç¼©æ”¾æ˜¾ç¤º
        speedData.push(avgSpeed*2); // ç¼©æ”¾æ˜¾ç¤º
      }

      // ç»˜åˆ¶æ›²çº¿
      drawChart(latencyCanvas, latencyData, "å»¶è¿Ÿ(ms,ç¼©æ”¾)");
      drawChart(speedCanvas, speedData, "ä¸‹è½½é€Ÿåº¦(Mbps,ç¼©æ”¾)");

      // è®¡ç®—ç¨³å®šæ€§åˆ†æ•°
      const stabilityScore = Math.max(0, 100 - failedRequests/totalRequests*100);
      resultsDiv.innerHTML = `
        <div class="metric"><b>æ€»è¯·æ±‚ï¼š</b> ${totalRequests}</div>
        <div class="metric"><b>å¤±è´¥è¯·æ±‚ï¼š</b> ${failedRequests}</div>
        <div class="metric"><b>ç¨³å®šæ€§è¯„åˆ†ï¼š</b> ${stabilityScore.toFixed(0)} / 100</div>
        <div class="metric"><b>å‹åŠ›åˆ†çº§ï¼š</b> ${stabilityGrade(stabilityScore)}</div>
        <p>æ›²çº¿å›¾æ˜¾ç¤ºå»¶è¿Ÿå’Œä¸‹è½½é€Ÿç‡å˜åŒ–æƒ…å†µï¼Œè¶Šå¹³æ»‘è¶Šç¨³å®šã€‚</p>
      `;
      countdownDiv.textContent = "æµ‹è¯•å®Œæˆ âœ…";
    });
  </script>
</body>
</html>
