# 防抖(debounce)和节流(throttle)的典型场景
## 概念
### 防抖 debounce
持续输入，仅最后一次操作结束后，短暂延迟后触发  
常规延迟时间 200ms ~ 500ms，不建议低于 100ms，否则防抖效果较弱。

### 节流 throttle
设定时间内控制触发次数，比如 1s 内，只触发一次

## 场景 
**当用户操作一个按钮，该按钮异步触发请求接口并将接口返回的数据呈现到当前页面，这个场景需要防抖还是节流？**

如果用户体验要求不是很高，时效性不是很强。防抖和节流都可以，目的是为了防止短时间内连续多次点击，发送多次不必要的请求。  
但是如果深究细节，就不难出防抖和节流是有根本区别的。我们先来看下用户行为习惯。

**行为习惯分析**  

参考：Robert Miller (1968)《Response time in man-computer conversational transactions》

- 低于 100ms 的响应通常被认为是 即时的（Instantaneous），用户几乎不会察觉到延迟。
- 超过 100ms，用户会感受到明显的迟滞感（Lag）  
- 200 ~ 250ms 是可接受的交互延迟（Jakob Nielsen (1993)《Usability Engineering》）  
- 超过 250ms：用户开始感到不耐烦，尤其是在频繁操作的情况下（如点击、输入）
- 1000ms（1s）以上：用户会察觉到等待，并可能转移注意力，影响交互体验。（Card, Moran, & Newell (1983)《The Psychology of Human-Computer Interaction》）

**基于行为习惯分析，如果用户操作的时效性很强，点击按钮后立刻需要响应。**

假如这时候使用防抖，采用 200ms 来滞后，用户这 200ms 是能感受得到 UI 迟滞。补救方案是 UI 反应要立即触发，请求 200ms 后触发，消除用户的迟滞感。但这时压力就到了业务方。业务方如果必须在 1.5s 内出返回结果并呈现到页面，这个性能指标就白白损失了 200ms（1.5s 的 13%），显然防抖不太适合这种场景。

如果使用节流

### 防抖的典型场景  
表单输入（实时搜索）、窗口调整（resize 事件触发后再执行）

### 节流的典型场景  
按钮点击、窗口滑动、鼠标拖拽（比如 onMouseMove）
